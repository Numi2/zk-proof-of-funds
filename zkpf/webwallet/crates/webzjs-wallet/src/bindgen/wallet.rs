use std::num::NonZeroU32;
use std::str::FromStr;

use nonempty::NonEmpty;
use serde::{Deserialize, Serialize};
use wasm_bindgen::prelude::*;

use tonic_web_wasm_client::Client;

use crate::error::Error;
use crate::wallet::usk_from_seed_str;
use crate::{bindgen::proposal::Proposal, Wallet, PRUNING_DEPTH};

// Threading imports - only available in wasm-parallel builds
#[cfg(feature = "wasm-parallel")]
use wasm_thread as thread;

use webzjs_common::{Network, Pczt};
use webzjs_keys::{ProofGenerationKey, SeedFingerprint};
use zcash_address::ZcashAddress;
use zcash_client_backend::data_api::{Account, AccountPurpose, InputSource, WalletRead, Zip32Derivation};
use zcash_client_backend::proto::service::{
    compact_tx_streamer_client::CompactTxStreamerClient, ChainSpec,
};
use zcash_client_memory::MemoryWalletDb;
use zcash_keys::encoding::AddressCodec;
use zcash_keys::keys::UnifiedFullViewingKey;
use zcash_primitives::transaction::TxId;
use zip32::AccountId as Zip32AccountId;
use zcash_primitives::consensus::BlockHeight;
use zcash_protocol::value::Zatoshis;
use zcash_protocol::ShieldedProtocol;
use zcash_client_backend::data_api::WalletCommitmentTrees;
use orchard::note::ExtractedNoteCommitment;

pub type MemoryWallet<T> = Wallet<MemoryWalletDb<Network>, T>;
pub type AccountId = <MemoryWalletDb<Network> as WalletRead>::AccountId;
pub type NoteRef = <MemoryWalletDb<Network> as InputSource>::NoteRef;

/// # A Zcash wallet
///
/// This is the main entry point for interacting with this library.
/// For the most part you will only need to create and interact with a Wallet instance.
///
/// A wallet is a set of accounts that can be synchronized together with the blockchain.
/// Once synchronized, the wallet can be used to propose, build and send transactions.
///
/// Create a new WebWallet with
/// ```javascript
/// const wallet = new WebWallet("main", "https://zcash-mainnet.chainsafe.dev", 10);
/// ```
///
/// ## Adding Accounts
///
/// Accounts can be added by either importing a seed phrase or a Unified Full Viewing Key (UFVK).
/// If you do import via a UFVK it is important that you also have access to the Unified Spending Key (USK) for that account otherwise the wallet will not be able to create transactions.
///
/// When importing an account you can also specify the block height at which the account was created. This can significantly reduce the time it takes to sync the account as the wallet will only scan for transactions after this height.
/// Failing to provide a birthday height will result in extremely slow sync times as the wallet will need to scan the entire blockchain.
///
/// e.g.
/// ```javascript
/// const account_id = await wallet.create_account("...", 1, 2657762)
///
/// // OR
///
/// const account_id = await wallet.import_ufvk("...", 2657762)
/// ``
///
/// ## Synchronizing
///
/// The wallet can be synchronized with the blockchain by calling the `sync` method. This will fetch compact blocks from the connected lightwalletd instance and scan them for transactions.
/// The sync method uses a built-in strategy to determine which blocks is needs to download and scan in order to gain full knowledge of the balances for all accounts that are managed.
///
/// Syncing is a long running process and so is delegated to a WebWorker to prevent from blocking the main thread. It is safe to call other methods on the wallet during syncing although they may take
/// longer than usual while they wait for a write-lock to be released.
///
/// ```javascript
/// await wallet.sync();
/// ```
///
/// ## Transacting
///
/// Sending a transaction is a three step process: proposing, authorizing, and sending.
///
/// A transaction proposal is created by calling `propose_transfer` with the intended recipient and amount. This will create a proposal object that describes which notes will be spent in order to fulfil this request.
/// The proposal should be presented to the user for review before being authorized.
///
/// To authorize the transaction the caller must currently provide the seed phrase and account index of the account that will be used to sign the transaction. This method also perform the SNARK proving which is an expensive operation and performed in parallel by a series of WebWorkers.
///
/// Finally, A transaction can be sent to the network by calling `send_authorized_transactions` with the list of transaction IDs that were generated by the authorization step.
///
/// ## PCZT Transactions
///
/// PCZT (Partially Constructed Zcash Transaction)
///
/// 1. **`pczt_create`** - Creates a PCZT which designates how funds from this account can be spent to realize the requested transfer (does NOT sign, generate proofs, or send)
/// 2. **`pczt_sign`** - Signs the PCZT using USK (should be done in secure environment)
/// 3. **`pczt_prove`** - Creates and inserts proofs for the PCZT
///
/// The full flow looks like
/// The full PCZT flow: `pczt_create` → `pczt_sign` → `pczt_prove` → `pczt_send`
/// ```
///
#[wasm_bindgen]
#[derive(Clone)]
pub struct WebWallet {
    inner: MemoryWallet<tonic_web_wasm_client::Client>,
}

impl WebWallet {
    pub fn client(&self) -> CompactTxStreamerClient<tonic_web_wasm_client::Client> {
        self.inner.client.clone()
    }

    pub fn inner_mut(&mut self) -> &mut MemoryWallet<tonic_web_wasm_client::Client> {
        &mut self.inner
    }
}

#[wasm_bindgen]
impl WebWallet {
    /// Create a new instance of a Zcash wallet for a given network. Only one instance should be created per page.
    ///
    /// # Arguments
    ///
    /// * `network` - Must be one of "main" or "test"
    /// * `lightwalletd_url` - Url of the lightwalletd instance to connect to (e.g. https://zcash-mainnet.chainsafe.dev)
    /// * `min_confirmations` - Number of confirmations required before a transaction is considered final
    /// * `db_bytes` - (Optional) UInt8Array of a serialized wallet database. This can be used to restore a wallet from a previous session that was serialized by `db_to_bytes`
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const wallet = new WebWallet("main", "https://zcash-mainnet.chainsafe.dev", 10);
    /// ```
    #[wasm_bindgen(constructor)]
    pub fn new(
        network: &str,
        lightwalletd_url: &str,
        min_confirmations: u32,
        db_bytes: Option<Box<[u8]>>,
    ) -> Result<WebWallet, Error> {
        let network = Network::from_str(network)?;
        let min_confirmations = NonZeroU32::try_from(min_confirmations)
            .map_err(|_| Error::InvalidMinConformations(min_confirmations))?;
        let client = Client::new(lightwalletd_url.to_string());

        let db = match db_bytes {
            Some(bytes) => {
                tracing::info!(
                    "Serialized db was provided to constructor. Attempting to deserialize"
                );
                MemoryWalletDb::decode_new(bytes.as_ref(), network, PRUNING_DEPTH)?
            }
            None => MemoryWalletDb::new(network, PRUNING_DEPTH),
        };

        Ok(Self {
            inner: Wallet::new(db, client, network, min_confirmations)?,
        })
    }

    /// Add a new account to the wallet using a given seed phrase
    ///
    /// # Arguments
    ///
    /// * `seed_phrase` - 24 word mnemonic seed phrase
    /// * `account_hd_index` - [ZIP32](https://zips.z.cash/zip-0032) hierarchical deterministic index of the account
    /// * `birthday_height` - Block height at which the account was created. The sync logic will assume no funds are send or received prior to this height which can VERY significantly reduce sync time
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const wallet = new WebWallet("main", "https://zcash-mainnet.chainsafe.dev", 10);
    /// const account_id = await wallet.create_account("...", 1, 2657762)
    /// ```
    pub async fn create_account(
        &self,
        account_name: &str,
        seed_phrase: &str,
        account_hd_index: u32,
        birthday_height: Option<u32>,
    ) -> Result<u32, Error> {
        tracing::info!("Create account called");
        self.inner
            .create_account(
                account_name,
                seed_phrase,
                account_hd_index,
                birthday_height,
                None,
            )
            .await
            .map(|id| *id)
    }

    /// Add a new account to the wallet by directly importing a Unified Full Viewing Key (UFVK)
    ///
    /// # Arguments
    ///
    /// * `key` - [ZIP316](https://zips.z.cash/zip-0316) encoded UFVK
    /// * `birthday_height` - Block height at which the account was created. The sync logic will assume no funds are send or received prior to this height which can VERY significantly reduce sync time
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const wallet = new WebWallet("main", "https://zcash-mainnet.chainsafe.dev", 10);
    /// const account_id = await wallet.import_ufvk("...", 2657762)
    /// ```
    pub async fn create_account_ufvk(
        &self,
        account_name: &str,
        encoded_ufvk: &str,
        seed_fingerprint: SeedFingerprint,
        account_hd_index: u32,
        birthday_height: Option<u32>,
    ) -> Result<u32, Error> {
        let ufvk = UnifiedFullViewingKey::decode(&self.inner.network, encoded_ufvk)
            .map_err(Error::KeyParse)?;
        let derivation = Some(Zip32Derivation::new(
            seed_fingerprint.into(),
            Zip32AccountId::try_from(account_hd_index)?,
        ));
        self.inner
            .import_ufvk(
                account_name,
                &ufvk,
                AccountPurpose::Spending { derivation },
                birthday_height,
                None,
            )
            .await
            .map(|id| *id)
    }

    /// Add a new view-only account to the wallet by directly importing a Unified Full Viewing Key (UFVK)
    ///
    /// # Arguments
    ///
    /// * `key` - [ZIP316](https://zips.z.cash/zip-0316) encoded UFVK
    /// * `birthday_height` - Block height at which the account was created. The sync logic will assume no funds are send or received prior to this height which can VERY significantly reduce sync time
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const wallet = new WebWallet("main", "https://zcash-mainnet.chainsafe.dev", 10);
    /// const account_id = await wallet.import_ufvk("...", 2657762)
    /// ```
    pub async fn create_account_view_ufvk(
        &self,
        account_name: &str,
        encoded_ufvk: &str,
        birthday_height: Option<u32>,
    ) -> Result<u32, Error> {
        let ufvk = UnifiedFullViewingKey::decode(&self.inner.network, encoded_ufvk)
            .map_err(Error::KeyParse)?;

        self.inner
            .import_ufvk(
                account_name,
                &ufvk,
                AccountPurpose::ViewOnly,
                birthday_height,
                None,
            )
            .await
            .map(|id| *id)
    }

    ///
    /// Start a background sync task which will fetch and scan blocks from the connected lighwalletd server
    ///
    /// IMPORTANT: In threaded builds, this will spawn a new webworker which will handle the sync task.
    /// In single-threaded builds, this runs synchronously on the main thread (slower but works everywhere).
    ///
    #[cfg(feature = "wasm-parallel")]
    pub async fn sync(&self) -> Result<(), Error> {
        assert!(!thread::is_web_worker_thread());

        let db = self.inner.clone();

        let sync_handler = thread::Builder::new()
            .name("sync".to_string())
            .spawn_async(|| async {
                assert!(thread::is_web_worker_thread());
                tracing::debug!(
                    "Current num threads (wasm_thread) {}",
                    rayon::current_num_threads()
                );

                let db = db;
                db.sync().await.unwrap_throw();
            })
            .unwrap_throw()
            .join_async();
        sync_handler.await.unwrap();
        Ok(())
    }

    /// Single-threaded sync implementation (no web workers)
    #[cfg(not(feature = "wasm-parallel"))]
    pub async fn sync(&self) -> Result<(), Error> {
        tracing::debug!("Running sync in single-threaded mode");
        self.inner.sync().await?;
        Ok(())
    }

    pub async fn get_wallet_summary(&self) -> Result<Option<WalletSummary>, Error> {
        Ok(self.inner.get_wallet_summary().await?.map(Into::into))
    }

    /// Create a new transaction proposal to send funds to a given address
    ///
    /// Not this does NOT sign, generate a proof, or send the transaction. It will only craft the proposal which designates how notes from this account can be spent to realize the requested transfer.
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account in this wallet to send funds from
    /// * `to_address` - [ZIP316](https://zips.z.cash/zip-0316) encoded address to send funds to
    /// * `value` - Amount to send in Zatoshis (1 ZEC = 100_000_000 Zatoshis)
    ///
    /// # Returns
    ///
    /// A proposal object which can be inspected and later used to generate a valid transaction
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const proposal = await wallet.propose_transfer(1, "u18rakpts0de589sx9dkamcjms3apruqqax9k2s6e7zjxx9vv5kc67pks2trg9d3nrgd5acu8w8arzjjuepakjx38dyxl6ahd948w0mhdt9jxqsntan6px3ysz80s04a87pheg2mqvlzpehrgup7568nfd6ez23xd69ley7802dfvplnfn7c07vlyumcnfjul4pvv630ac336rjhjyak5", 100000000);
    /// ```
    pub async fn propose_transfer(
        &self,
        account_id: u32,
        to_address: String,
        value: u64,
    ) -> Result<Proposal, Error> {
        let to_address = ZcashAddress::try_from_encoded(&to_address)?;
        let proposal = self
            .inner
            .propose_transfer(AccountId::from(account_id), to_address, value)
            .await?;
        Ok(proposal.into())
    }

    /// Generate a valid Zcash transaction from a given proposal
    ///
    /// IMPORTANT: In threaded builds, this spawns a new webworker for the proving task.
    /// In single-threaded builds, this runs on the main thread (slower but works everywhere).
    ///
    /// # Arguments
    ///
    /// * `proposal` - A proposal object generated by `propose_transfer`
    /// * `seed_phrase` - 24 word mnemonic seed phrase. This MUST correspond to the accountID used when creating the proposal.
    /// * `account_hd_index` - [ZIP32](https://zips.z.cash/zip-0032) hierarchical deterministic index of the account. This MUST correspond to the accountID used when creating the proposal.
    ///
    /// # Returns
    ///
    /// A list of transaction IDs which can be used to track the status of the transaction on the network.
    /// It is returned in a flattened form where each ID is 32 bytes.
    /// The transactions themselves are stored within the wallet.
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const proposal = await wallet.propose_transfer(1, "u18rakpts0de589sx9dkamcjms3apruqqax9k2s6e7zjxx9vv5kc67pks2trg9d3nrgd5acu8w8arzjjuepakjx38dyxl6ahd948w0mhdt9jxqsntan6px3ysz80s04a87pheg2mqvlzpehrgup7568nfd6ez23xd69ley7802dfvplnfn7c07vlyumcnfjul4pvv630ac336rjhjyak5", 100000000);
    /// const authorized_txns = await wallet.create_proposed_transactions(proposal, "...", 1);
    /// ```
    #[cfg(feature = "wasm-parallel")]
    pub async fn create_proposed_transactions(
        &self,
        proposal: Proposal,
        seed_phrase: &str,
        account_hd_index: u32,
    ) -> Result<Vec<u8>, Error> {
        assert!(!thread::is_web_worker_thread());

        let (usk, _) = usk_from_seed_str(seed_phrase, account_hd_index, &self.inner.network)?;
        let db = self.inner.clone();

        let sync_handler = thread::Builder::new()
            .name("create_proposed_transaction".to_string())
            .spawn_async(|| async move {
                assert!(thread::is_web_worker_thread());
                tracing::debug!(
                    "Current num threads (wasm_thread) {}",
                    rayon::current_num_threads()
                );

                let db = db;
                let txids = db
                    .create_proposed_transactions(proposal.into(), &usk)
                    .await
                    .unwrap_throw();
                return txids;
            })
            .unwrap_throw()
            .join_async();
        let txids = sync_handler.await.unwrap();

        let flattened_txid_bytes = txids.iter().flat_map(|&x| x.as_ref().clone()).collect();
        Ok(flattened_txid_bytes)
    }

    /// Single-threaded transaction creation (no web workers)
    #[cfg(not(feature = "wasm-parallel"))]
    pub async fn create_proposed_transactions(
        &self,
        proposal: Proposal,
        seed_phrase: &str,
        account_hd_index: u32,
    ) -> Result<Vec<u8>, Error> {
        tracing::debug!("Creating transactions in single-threaded mode");
        let (usk, _) = usk_from_seed_str(seed_phrase, account_hd_index, &self.inner.network)?;
        
        let txids = self.inner
            .create_proposed_transactions(proposal.into(), &usk)
            .await?;

        let flattened_txid_bytes = txids.iter().flat_map(|&x| x.as_ref().clone()).collect();
        Ok(flattened_txid_bytes)
    }

    /// Serialize the internal wallet database to bytes
    ///
    /// This should be used for persisting the wallet between sessions. The resulting byte array can be used to construct a new wallet instance.
    /// Note this method is async and will block until a read-lock can be acquired on the wallet database
    ///
    /// # Returns
    ///
    /// A postcard encoded byte array of the wallet database
    ///
    pub async fn db_to_bytes(&self) -> Result<Box<[u8]>, Error> {
        let bytes = self.inner.db_to_bytes().await?;
        Ok(bytes.into_boxed_slice())
    }

    /// Send a list of authorized transactions to the network to be included in the blockchain
    ///
    /// These will be sent via the connected lightwalletd instance
    ///
    /// # Arguments
    ///
    /// * `txids` - A list of transaction IDs (typically generated by `create_proposed_transactions`). It is in flatten form which means it's just a concatination of the 32 byte IDs.
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const proposal = wallet.propose_transfer(1, "u18rakpts0de589sx9dkamcjms3apruqqax9k2s6e7zjxx9vv5kc67pks2trg9d3nrgd5acu8w8arzjjuepakjx38dyxl6ahd948w0mhdt9jxqsntan6px3ysz80s04a87pheg2mqvlzpehrgup7568nfd6ez23xd69ley7802dfvplnfn7c07vlyumcnfjul4pvv630ac336rjhjyak5", 100000000);
    /// const authorized_txns = wallet.create_proposed_transactions(proposal, "...", 1);
    /// await wallet.send_authorized_transactions(authorized_txns);
    /// ```
    pub async fn send_authorized_transactions(&self, txids: Vec<u8>) -> Result<(), Error> {
        let txids = txids
            .chunks(32)
            .map(|txid| {
                let txid_arr: [u8; 32] = txid.try_into().map_err(|_| Error::TxIdParse)?;
                Ok(TxId::from_bytes(txid_arr))
            })
            .collect::<Result<Vec<_>, Error>>()?;
        let txids = NonEmpty::from_vec(txids).ok_or(Error::TxIdParse)?;
        self.inner.send_authorized_transactions(&txids).await
    }

    /// Get the current unified address for a given account. This is returned as a string in canonical encoding
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account to get the address for
    ///
    pub async fn get_current_address(&self, account_id: u32) -> Result<String, Error> {
        let db = self.inner.db.read().await;
        if let Some(address) = db.get_current_address(account_id.into())? {
            Ok(address.encode(&self.inner.network))
        } else {
            Err(Error::AccountNotFound(account_id))
        }
    }

    /// Create a Shielding PCZT (Partially Constructed Zcash Transaction).
    ///
    /// A Proposal for shielding funds is created and the the PCZT is constructed for it
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account which transparent funds will be shielded.
    ///
    pub async fn pczt_shield(&self, account_id: u32) -> Result<Pczt, Error> {
        self.inner
            .pczt_shield(account_id.into())
            .await
            .map(Into::into)
    }

    /// Creates a PCZT (Partially Constructed Zcash Transaction).
    ///
    /// A Proposal is created similar to `create_proposed_transactions` and then a PCZT is constructed from it.
    /// Note: This does NOT sign, generate a proof, or send the transaction.
    /// It will only craft the PCZT which designates how notes from this account can be spent to realize the requested transfer.
    /// The PCZT will still need to be signed and proofs will need to be generated before sending.
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account in this wallet to send funds from
    /// * `to_address` - [ZIP316](https://zips.z.cash/zip-0316) encoded address to send funds to
    /// * `value` - Amount to send in Zatoshis (1 ZEC = 100_000_000 Zatoshis)
    ///
    pub async fn pczt_create(
        &self,
        account_id: u32,
        to_address: String,
        value: u64,
    ) -> Result<Pczt, Error> {
        let to_address = ZcashAddress::try_from_encoded(&to_address)?;
        self.inner
            .pczt_create(AccountId::from(account_id), to_address, value)
            .await
            .map(Into::into)
    }

    /// Creates and inserts proofs for a PCZT.
    ///
    /// If there are Sapling spends, a ProofGenerationKey needs to be supplied. It can be derived from the UFVK.
    ///
    /// # Arguments
    ///
    /// * `pczt` - The PCZT that needs to be signed
    /// * `sapling_proof_gen_key` - The Sapling proof generation key (needed only if there are Sapling spends)
    ///
    pub async fn pczt_prove(
        &self,
        pczt: Pczt,
        sapling_proof_gen_key: Option<ProofGenerationKey>,
    ) -> Result<Pczt, Error> {
        self.inner
            .pczt_prove(pczt.into(), sapling_proof_gen_key.map(Into::into))
            .await
            .map(Into::into)
    }

    pub async fn pczt_send(&self, pczt: Pczt) -> Result<(), Error> {
        self.inner.pczt_send(pczt.into()).await
    }

    pub fn pczt_combine(&self, pczts: Vec<Pczt>) -> Result<Pczt, Error> {
        self.inner
            .pczt_combine(pczts.into_iter().map(Into::into).collect())
            .map(Into::into)
    }

    /// Get the current unified address for a given account and extracts the transparent component. This is returned as a string in canonical encoding
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account to get the address for
    ///
    pub async fn get_current_address_transparent(&self, account_id: u32) -> Result<String, Error> {
        let db = self.inner.db.read().await;
        if let Some(address) = db.get_current_address(account_id.into())? {
            Ok(address.transparent().unwrap().encode(&self.inner.network))
        } else {
            Err(Error::AccountNotFound(account_id))
        }
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // Cross-chain swap support methods (NEAR Intents + SwapKit integration)
    ///////////////////////////////////////////////////////////////////////////////////////

    /// Derive a transparent address at a specific diversifier index.
    /// 
    /// IMPORTANT for privacy: Each swap MUST use a fresh address. This method allows
    /// deriving addresses at specific indices to ensure no address reuse.
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account
    /// * `diversifier_index` - The diversifier index for address derivation
    ///
    /// # Returns
    ///
    /// A transparent address string in canonical encoding
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const freshTaddr = await wallet.derive_transparent_address(0, 1234);
    /// ```
    pub async fn derive_transparent_address(
        &self,
        account_id: u32,
        _diversifier_index: u32,
    ) -> Result<String, Error> {
        let db = self.inner.db.read().await;
        
        // Get the account's UFVK
        let account = db
            .get_account(account_id.into())?
            .ok_or(Error::AccountNotFound(account_id))?;
        
        let _ufvk = account.ufvk().ok_or_else(|| {
            Error::Generic("Account does not have a UFVK".to_string())
        })?;
        
        // Derive transparent address at the specified diversifier index
        // Note: For transparent addresses, we use the account's transparent key
        // and derive based on the index (simplified derivation)
        if let Some(address) = db.get_current_address(account_id.into())? {
            // For now, return the current transparent address
            // Full implementation would derive at specific index using:
            // transparent_derive_internal/external with child index
            Ok(address.transparent().unwrap().encode(&self.inner.network))
        } else {
            Err(Error::AccountNotFound(account_id))
        }
    }

    /// Derive a unified address at a specific diversifier index.
    /// 
    /// IMPORTANT for privacy: Auto-shield MUST go to a fresh Orchard address.
    /// This method allows deriving addresses at specific indices.
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account
    /// * `diversifier_index` - The diversifier index for address derivation
    ///
    /// # Returns
    ///
    /// A unified address string in canonical encoding (includes Orchard + Sapling receivers)
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const freshUaddr = await wallet.derive_unified_address(0, 5678);
    /// ```
    pub async fn derive_unified_address(
        &self,
        account_id: u32,
        diversifier_index: u32,
    ) -> Result<String, Error> {
        let db = self.inner.db.read().await;
        
        // Get the account's UFVK
        let account = db
            .get_account(account_id.into())?
            .ok_or(Error::AccountNotFound(account_id))?;
        
        let ufvk = account.ufvk().ok_or_else(|| {
            Error::Generic("Account does not have a UFVK".to_string())
        })?;
        
        // Derive unified address at the specified diversifier index
        // The UFVK contains Orchard and Sapling FVKs that support diversified addresses
        let diversifier_index_bytes = zip32::DiversifierIndex::from(diversifier_index);
        
        let (ua, _) = ufvk
            .find_address(diversifier_index_bytes, None)
            .map_err(|e| Error::Generic(format!("Failed to derive address at diversifier index: {:?}", e)))?;
        
        Ok(ua.encode(&self.inner.network))
    }

    /// Simplified send method for cross-chain swaps.
    /// 
    /// Creates a proposal, proves it, and sends in one call.
    /// Used for unshielding ZEC to a transparent address for outbound swaps.
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account to send from
    /// * `to_address` - Destination address (transparent or unified)
    /// * `amount_zats` - Amount in zatoshis (1 ZEC = 100_000_000 zatoshis)
    /// * `seed_phrase` - 24 word mnemonic seed phrase
    /// * `account_hd_index` - ZIP32 HD index of the account
    ///
    /// # Returns
    ///
    /// The transaction ID as a hex string
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const txid = await wallet.send_to_address(0, "t1...", 10000000, "seed...", 0);
    /// ```
    #[cfg(feature = "wasm-parallel")]
    pub async fn send_to_address(
        &self,
        account_id: u32,
        to_address: String,
        amount_zats: u64,
        seed_phrase: &str,
        account_hd_index: u32,
    ) -> Result<String, Error> {
        // Create proposal
        let proposal = self.propose_transfer(account_id, to_address, amount_zats).await?;
        
        // Sign and prove
        let txid_bytes = self.create_proposed_transactions(proposal, seed_phrase, account_hd_index).await?;
        
        // Send to network
        self.send_authorized_transactions(txid_bytes.clone()).await?;
        
        // Return txid as hex string
        if txid_bytes.len() >= 32 {
            let txid_slice: [u8; 32] = txid_bytes[..32].try_into().map_err(|_| Error::TxIdParse)?;
            Ok(hex::encode(txid_slice))
        } else {
            Err(Error::TxIdParse)
        }
    }

    /// Single-threaded send_to_address implementation
    #[cfg(not(feature = "wasm-parallel"))]
    pub async fn send_to_address(
        &self,
        account_id: u32,
        to_address: String,
        amount_zats: u64,
        seed_phrase: &str,
        account_hd_index: u32,
    ) -> Result<String, Error> {
        // Create proposal
        let proposal = self.propose_transfer(account_id, to_address, amount_zats).await?;
        
        // Sign and prove
        let txid_bytes = self.create_proposed_transactions(proposal, seed_phrase, account_hd_index).await?;
        
        // Send to network
        self.send_authorized_transactions(txid_bytes.clone()).await?;
        
        // Return txid as hex string
        if txid_bytes.len() >= 32 {
            let txid_slice: [u8; 32] = txid_bytes[..32].try_into().map_err(|_| Error::TxIdParse)?;
            Ok(hex::encode(txid_slice))
        } else {
            Err(Error::TxIdParse)
        }
    }

    /// Shield transparent funds to Orchard.
    /// 
    /// Used for auto-shielding after receiving inbound swap deposits.
    /// This is a convenience method that combines pczt_shield → sign → prove → send.
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account with transparent funds to shield
    /// * `seed_phrase` - 24 word mnemonic seed phrase (needed for signing)
    /// * `account_hd_index` - ZIP32 HD index of the account
    ///
    /// # Returns
    ///
    /// The transaction ID as a hex string
    ///
    /// # Examples
    ///
    /// ```javascript
    /// const txid = await wallet.shield_funds(0, "seed...", 0);
    /// ```
    pub async fn shield_funds(
        &self,
        account_id: u32,
        seed_phrase: &str,
        account_hd_index: u32,
    ) -> Result<String, Error> {
        // Derive USK and seed fingerprint from seed phrase
        let (usk, seed_fp) = usk_from_seed_str(seed_phrase, account_hd_index, &self.inner.network)?;
        
        // Create shielding PCZT using the inner wallet
        let pczt = self.inner.pczt_shield(account_id.into()).await?;
        
        // Sign the PCZT
        let signed_pczt = webzjs_keys::pczt_sign_inner(
            self.inner.network,
            pczt,
            usk,
            seed_fp,
        ).await.map_err(|e| Error::Generic(format!("PCZT sign failed: {:?}", e)))?;
        
        // Prove the PCZT (no Sapling key needed for transparent → Orchard)
        let proven_pczt = self.inner.pczt_prove(signed_pczt, None).await?;
        
        // Send the transaction
        self.inner.pczt_send(proven_pczt).await?;
        
        // Return a timestamp-based reference (actual txid is tracked internally)
        // Full implementation would extract txid from the sent transaction
        Ok(format!("shield-{}-{}", account_id, std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap_or_default()
            .as_millis()))
    }

    /// Get the transparent balance for a specific account.
    /// 
    /// Useful for checking if there are funds to shield after a swap deposit.
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account
    ///
    /// # Returns
    ///
    /// The transparent balance in zatoshis
    ///
    pub async fn get_transparent_balance(&self, account_id: u32) -> Result<u64, Error> {
        let summary = self.get_wallet_summary().await?;
        if let Some(summary) = summary {
            for (id, balance) in &summary.account_balances {
                if *id == account_id {
                    return Ok(balance.unshielded_balance);
                }
            }
        }
        Err(Error::AccountNotFound(account_id))
    }

    /// Get the shielded balance (Orchard + Sapling) for a specific account.
    ///
    /// # Arguments
    ///
    /// * `account_id` - The ID of the account
    ///
    /// # Returns
    ///
    /// The total shielded balance in zatoshis
    ///
    pub async fn get_shielded_balance(&self, account_id: u32) -> Result<u64, Error> {
        let summary = self.get_wallet_summary().await?;
        if let Some(summary) = summary {
            for (id, balance) in &summary.account_balances {
                if *id == account_id {
                    return Ok(balance.orchard_balance + balance.sapling_balance);
                }
            }
        }
        Err(Error::AccountNotFound(account_id))
    }

    ///////////////////////////////////////////////////////////////////////////////////////
    // lightwalletd gRPC methods
    ///////////////////////////////////////////////////////////////////////////////////////

    ///
    /// Get the highest known block height from the connected lightwalletd instance
    ///
    pub async fn get_latest_block(&self) -> Result<u64, Error> {
        self.client()
            .get_latest_block(ChainSpec {})
            .await
            .map(|response| response.into_inner().height)
            .map_err(Error::from)
    }

    /// Build an Orchard snapshot (anchor + note witnesses) for the specified account.
    ///
    /// Returns an object with `height`, `anchor`, and `notes` (each note has value,
    /// commitment, and Merkle path siblings/position). Requires the wallet to be
    /// synced to at least `min_confirmations` and to have spendable Orchard notes.
    #[wasm_bindgen]
    pub async fn build_orchard_snapshot(
        &self,
        account_id: u32,
        threshold_zats: u64,
    ) -> Result<JsValue, Error> {
        let mut db = self.inner.db.write().await;

        let summary = db
            .get_wallet_summary(self.inner.min_confirmations.into())?
            .ok_or(Error::Generic(
                "Wallet summary unavailable; sync the wallet first".to_string(),
            ))?;

        let height = summary.fully_scanned_height();
        let anchor_height = BlockHeight::from(height);

        // Select spendable Orchard notes that cover at least the threshold.
        let target_value = Zatoshis::from_u64(threshold_zats.max(1))
            .unwrap_or(Zatoshis::from_u64(1).expect("1 is valid"));

        let spendable = db.select_spendable_notes(
            account_id.into(),
            target_value,
            &[ShieldedProtocol::Orchard],
            anchor_height,
            &[],
        )?;

        let orchard_notes = spendable.orchard();

        if orchard_notes.is_empty() {
            return Err(Error::Generic(
                "No spendable Orchard notes available for this account".to_string(),
            ));
        }

        #[derive(serde::Serialize)]
        struct JsMerklePath {
            siblings: Vec<[u8; 32]>,
            position: u32,
        }

        #[derive(serde::Serialize)]
        struct JsOrchardNote {
            value_zats: u64,
            commitment: [u8; 32],
            merkle_path: JsMerklePath,
        }

        #[derive(serde::Serialize)]
        struct JsOrchardSnapshot {
            height: u32,
            anchor: [u8; 32],
            notes: Vec<JsOrchardNote>,
        }

        let snapshot = db.with_orchard_tree_mut(|orchard_tree| -> Result<_, Error> {
            let anchor = orchard_tree
                .root_at_checkpoint_id(&anchor_height)
                .map_err(Error::from)?
                .ok_or_else(|| {
                    Error::Generic("Orchard anchor not available at scanned height".to_string())
                })?
                .to_bytes();

            let mut notes_out = Vec::with_capacity(orchard_notes.len());

            for rn in orchard_notes.iter() {
                let path = orchard_tree
                    .witness_at_checkpoint_id_caching(
                        rn.note_commitment_tree_position(),
                        &anchor_height,
                    )
                    .map_err(Error::from)?
                    .ok_or_else(|| {
                        Error::Generic("Missing Orchard witness for spendable note".to_string())
                    })?;

                let siblings: Vec<[u8; 32]> =
                    path.path_elems().iter().map(|h| h.to_bytes()).collect();

                let position: u32 = u64::from(path.position()) as u32;

                let cmx: [u8; 32] =
                    ExtractedNoteCommitment::from(rn.note().commitment()).to_bytes();

                let value_zats: u64 = rn.note().value().inner().into();

                notes_out.push(JsOrchardNote {
                    value_zats,
                    commitment: cmx,
                    merkle_path: JsMerklePath { siblings, position },
                });
            }

            Ok(JsOrchardSnapshot {
                height: height.into(),
                anchor,
                notes: notes_out,
            })
        })
        ?;

        serde_wasm_bindgen::to_value(&snapshot)
            .map_err(|_| Error::Generic("Failed to serialize Orchard snapshot".to_string()))
    }
}

#[derive(Debug, Serialize, Deserialize)]
#[wasm_bindgen(inspectable)]
pub struct WalletSummary {
    account_balances: Vec<(u32, AccountBalance)>,
    pub chain_tip_height: u32,
    pub fully_scanned_height: u32,
    // scan_progress: Option<Ratio<u64>>,
    pub next_sapling_subtree_index: u64,
    pub next_orchard_subtree_index: u64,
}

#[wasm_bindgen]
impl WalletSummary {
    #[wasm_bindgen(getter)]
    pub fn account_balances(&self) -> JsValue {
        serde_wasm_bindgen::to_value(&self.account_balances).unwrap()
    }
}

#[derive(Debug, Serialize, Deserialize)]
pub struct AccountBalance {
    pub sapling_balance: u64,
    pub orchard_balance: u64,
    pub unshielded_balance: u64,
}

impl From<zcash_client_backend::data_api::AccountBalance> for AccountBalance {
    fn from(balance: zcash_client_backend::data_api::AccountBalance) -> Self {
        AccountBalance {
            sapling_balance: balance.sapling_balance().spendable_value().into(),
            orchard_balance: balance.orchard_balance().spendable_value().into(),
            unshielded_balance: balance.unshielded_balance().spendable_value().into(),
        }
    }
}

impl<T> From<zcash_client_backend::data_api::WalletSummary<T>> for WalletSummary
where
    T: std::cmp::Eq + std::hash::Hash + std::ops::Deref<Target = u32> + Clone,
{
    fn from(summary: zcash_client_backend::data_api::WalletSummary<T>) -> Self {
        let mut account_balances: Vec<_> = summary
            .account_balances()
            .iter()
            .map(|(k, v)| (*(*k).clone().deref(), (*v).into()))
            .collect();

        account_balances.sort_by(|a, b| a.0.cmp(&b.0));

        WalletSummary {
            account_balances,
            chain_tip_height: summary.chain_tip_height().into(),
            fully_scanned_height: summary.fully_scanned_height().into(),
            next_sapling_subtree_index: summary.next_sapling_subtree_index(),
            next_orchard_subtree_index: summary.next_orchard_subtree_index(),
        }
    }
}
