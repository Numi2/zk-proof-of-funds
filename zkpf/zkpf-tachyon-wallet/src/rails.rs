//! Rail abstraction layer for the Tachyon wallet.
//!
//! Each rail provides a specific proving capability. The Tachyon wallet
//! coordinates across rails to generate unified proofs.

use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::collections::HashSet;

use crate::config::{RailCapability, RailConfig};
use crate::error::TachyonError;
use crate::state::ChainBalance;
use crate::types::{CurrencyCode, Epoch, HolderId, Policy};
use zkpf_common::ProofBundle;

// ═══════════════════════════════════════════════════════════════════════════════
// RAIL IDENTIFIER
// ═══════════════════════════════════════════════════════════════════════════════

/// Canonical rail identifiers.
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum RailId {
    /// Zcash Orchard shielded pool.
    ZcashOrchard,
    /// Mina recursive proof aggregation.
    MinaRecursive,
    /// Starknet L2 accounts and DeFi.
    StarknetL2,
    /// Axelar cross-chain transport (not a proving rail).
    AxelarGmp,
    /// NEAR TEE agent (computation, not proving).
    NearTee,
    /// Custom rail with string identifier.
    Custom(String),
}

impl RailId {
    pub fn as_str(&self) -> &str {
        match self {
            Self::ZcashOrchard => "ZCASH_ORCHARD",
            Self::MinaRecursive => "MINA_RECURSIVE",
            Self::StarknetL2 => "STARKNET_L2",
            Self::AxelarGmp => "AXELAR_GMP",
            Self::NearTee => "NEAR_TEE",
            Self::Custom(s) => s,
        }
    }

    pub fn from_str(s: &str) -> Self {
        match s {
            "ZCASH_ORCHARD" => Self::ZcashOrchard,
            "MINA_RECURSIVE" => Self::MinaRecursive,
            "STARKNET_L2" => Self::StarknetL2,
            "AXELAR_GMP" => Self::AxelarGmp,
            "NEAR_TEE" => Self::NearTee,
            other => Self::Custom(other.to_string()),
        }
    }

    /// Get the capabilities this rail provides.
    pub fn capabilities(&self) -> HashSet<RailCapability> {
        match self {
            Self::ZcashOrchard => {
                [RailCapability::ShieldedBalance, RailCapability::PrivateTransfer]
                    .into_iter()
                    .collect()
            }
            Self::MinaRecursive => {
                [RailCapability::RecursiveProof, RailCapability::ProofAggregation]
                    .into_iter()
                    .collect()
            }
            Self::StarknetL2 => [
                RailCapability::DeFiPosition,
                RailCapability::AccountAbstraction,
                RailCapability::SessionKey,
            ]
            .into_iter()
            .collect(),
            Self::AxelarGmp => [RailCapability::CrossChainBridge].into_iter().collect(),
            Self::NearTee => [RailCapability::TeeCompute].into_iter().collect(),
            Self::Custom(_) => HashSet::new(),
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// RAIL TRAIT
// ═══════════════════════════════════════════════════════════════════════════════

/// Trait implemented by all proving rails.
#[async_trait]
pub trait Rail: Send + Sync {
    /// Get the rail identifier.
    fn id(&self) -> RailId;

    /// Get the capabilities this rail provides.
    fn capabilities(&self) -> HashSet<RailCapability>;

    /// Check if the rail is available and configured.
    async fn is_available(&self) -> bool;

    /// Synchronize the rail with its chain.
    async fn sync(&self) -> Result<SyncStatus, TachyonError>;

    /// Get the current balance for a currency.
    async fn get_balance(&self, currency: CurrencyCode) -> Result<ChainBalance, TachyonError>;

    /// Generate a proof-of-funds for the given policy.
    async fn prove(
        &self,
        holder_id: &HolderId,
        policy: &Policy,
        epoch: &Epoch,
    ) -> Result<ProofBundle, TachyonError>;

    /// Verify a proof generated by this rail.
    async fn verify(&self, bundle: &ProofBundle) -> Result<bool, TachyonError>;
}

/// Synchronization status for a rail.
#[derive(Clone, Debug, Serialize, Deserialize)]
pub struct SyncStatus {
    /// Whether sync is complete.
    pub synced: bool,
    /// Current chain height.
    pub chain_height: u64,
    /// Wallet/scan height.
    pub wallet_height: u64,
    /// Percentage complete (0-100).
    pub progress_pct: f32,
    /// Estimated time to completion (seconds).
    pub eta_secs: Option<u64>,
}

// ═══════════════════════════════════════════════════════════════════════════════
// ZCASH ORCHARD RAIL
// ═══════════════════════════════════════════════════════════════════════════════

/// Zcash Orchard rail implementation.
pub struct ZcashOrchardRail {
    config: RailConfig,
}

impl ZcashOrchardRail {
    pub fn new(config: RailConfig) -> Self {
        Self { config }
    }
}

#[async_trait]
impl Rail for ZcashOrchardRail {
    fn id(&self) -> RailId {
        RailId::ZcashOrchard
    }

    fn capabilities(&self) -> HashSet<RailCapability> {
        RailId::ZcashOrchard.capabilities()
    }

    async fn is_available(&self) -> bool {
        self.config.enabled
    }

    async fn sync(&self) -> Result<SyncStatus, TachyonError> {
        // TODO: Integrate with actual Orchard wallet sync
        Ok(SyncStatus {
            synced: true,
            chain_height: 0,
            wallet_height: 0,
            progress_pct: 100.0,
            eta_secs: None,
        })
    }

    async fn get_balance(&self, currency: CurrencyCode) -> Result<ChainBalance, TachyonError> {
        if currency != CurrencyCode::ZEC {
            return Ok(ChainBalance {
                total: 0,
                spendable: 0,
                pending: 0,
                currency,
                block_height: 0,
            });
        }

        // TODO: Get actual balance from Orchard wallet
        Ok(ChainBalance {
            total: 0,
            spendable: 0,
            pending: 0,
            currency,
            block_height: 0,
        })
    }

    async fn prove(
        &self,
        holder_id: &HolderId,
        policy: &Policy,
        epoch: &Epoch,
    ) -> Result<ProofBundle, TachyonError> {
        use zkpf_common::VerifierPublicInputs;

        // TODO: Generate actual Orchard PoF proof
        // For now, return a placeholder bundle

        let nullifier = compute_nullifier(holder_id, policy, epoch);
        
        let public_inputs = VerifierPublicInputs {
            threshold_raw: policy.threshold as u64,
            required_currency_code: policy.currency.as_u32(),
            current_epoch: epoch.timestamp,
            verifier_scope_id: policy.verifier_scope_id,
            policy_id: policy.policy_id,
            nullifier,
            custodian_pubkey_hash: [0u8; 32],
            snapshot_block_height: None,
            snapshot_anchor_orchard: None,
            holder_binding: Some(compute_holder_binding(holder_id)),
            proven_sum: None,
        };

        Ok(ProofBundle {
            rail_id: self.id().as_str().to_string(),
            circuit_version: zkpf_common::CIRCUIT_VERSION,
            proof: vec![], // Placeholder
            public_inputs,
        })
    }

    async fn verify(&self, _bundle: &ProofBundle) -> Result<bool, TachyonError> {
        // TODO: Implement actual verification
        Err(TachyonError::ProofVerification(
            "Orchard verification not yet implemented".into(),
        ))
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MINA RECURSIVE RAIL
// ═══════════════════════════════════════════════════════════════════════════════

/// Mina recursive proof aggregation rail.
pub struct MinaRecursiveRail {
    config: RailConfig,
}

impl MinaRecursiveRail {
    pub fn new(config: RailConfig) -> Self {
        Self { config }
    }
}

#[async_trait]
impl Rail for MinaRecursiveRail {
    fn id(&self) -> RailId {
        RailId::MinaRecursive
    }

    fn capabilities(&self) -> HashSet<RailCapability> {
        RailId::MinaRecursive.capabilities()
    }

    async fn is_available(&self) -> bool {
        self.config.enabled
    }

    async fn sync(&self) -> Result<SyncStatus, TachyonError> {
        Ok(SyncStatus {
            synced: true,
            chain_height: 0,
            wallet_height: 0,
            progress_pct: 100.0,
            eta_secs: None,
        })
    }

    async fn get_balance(&self, currency: CurrencyCode) -> Result<ChainBalance, TachyonError> {
        // Mina rail is for aggregation, not direct balance
        Ok(ChainBalance {
            total: 0,
            spendable: 0,
            pending: 0,
            currency,
            block_height: 0,
        })
    }

    async fn prove(
        &self,
        holder_id: &HolderId,
        policy: &Policy,
        epoch: &Epoch,
    ) -> Result<ProofBundle, TachyonError> {
        use zkpf_mina::{MinaPublicMeta, PublicMetaInputs, SourceProofInput};

        // Mina rail wraps other proofs recursively
        // For direct proving, we create a recursive wrapper

        let mina_meta = MinaPublicMeta {
            network_id: "mainnet".to_string(),
            network_id_numeric: 0,
            global_slot: epoch.timestamp,
            zkapp_address: "B62q...".to_string(), // TODO: Configure
            recursive_proof_commitment: [0u8; 32],
            source_rail_ids: vec![],
        };

        let public_meta = PublicMetaInputs {
            policy_id: policy.policy_id,
            verifier_scope_id: policy.verifier_scope_id,
            current_epoch: epoch.timestamp,
            required_currency_code: policy.currency.as_u32(),
        };

        // For now, create an empty wrapper
        // In production, this would aggregate source proofs
        let source_proofs: Vec<SourceProofInput> = vec![];

        if source_proofs.is_empty() {
            return Err(TachyonError::ProofGeneration(
                "Mina rail requires source proofs to aggregate".into(),
            ));
        }

        let bundle = zkpf_mina::prove_mina_recursive(
            &source_proofs,
            &holder_id.0,
            &mina_meta,
            &public_meta,
        )?;

        Ok(bundle)
    }

    async fn verify(&self, bundle: &ProofBundle) -> Result<bool, TachyonError> {
        zkpf_mina::verify_mina_proof(bundle).map_err(Into::into)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// STARKNET L2 RAIL
// ═══════════════════════════════════════════════════════════════════════════════

/// Starknet L2 rail implementation.
pub struct StarknetL2Rail {
    config: RailConfig,
}

impl StarknetL2Rail {
    pub fn new(config: RailConfig) -> Self {
        Self { config }
    }
}

#[async_trait]
impl Rail for StarknetL2Rail {
    fn id(&self) -> RailId {
        RailId::StarknetL2
    }

    fn capabilities(&self) -> HashSet<RailCapability> {
        RailId::StarknetL2.capabilities()
    }

    async fn is_available(&self) -> bool {
        self.config.enabled
    }

    async fn sync(&self) -> Result<SyncStatus, TachyonError> {
        Ok(SyncStatus {
            synced: true,
            chain_height: 0,
            wallet_height: 0,
            progress_pct: 100.0,
            eta_secs: None,
        })
    }

    async fn get_balance(&self, currency: CurrencyCode) -> Result<ChainBalance, TachyonError> {
        // TODO: Query Starknet RPC for actual balance
        Ok(ChainBalance {
            total: 0,
            spendable: 0,
            pending: 0,
            currency,
            block_height: 0,
        })
    }

    async fn prove(
        &self,
        holder_id: &HolderId,
        policy: &Policy,
        epoch: &Epoch,
    ) -> Result<ProofBundle, TachyonError> {
        use zkpf_starknet_l2::{
            PublicMetaInputs, StarknetAccountSnapshot, StarknetPublicMeta, StarknetSnapshot,
        };

        // TODO: Build actual snapshot from Starknet RPC
        let snapshot = StarknetSnapshot {
            chain_id: "SN_MAIN".to_string(),
            block_number: 0, // TODO: Get actual block
            block_hash: "0x0".to_string(),
            timestamp: epoch.timestamp,
            accounts: vec![],
        };

        let starknet_meta = StarknetPublicMeta {
            chain_id: snapshot.chain_id.clone(),
            chain_id_numeric: 0,
            block_number: snapshot.block_number,
            account_commitment: [0u8; 32],
            holder_binding: [0u8; 32],
        };

        let public_meta = PublicMetaInputs {
            policy_id: policy.policy_id,
            verifier_scope_id: policy.verifier_scope_id,
            current_epoch: epoch.timestamp,
            required_currency_code: policy.currency.as_u32(),
        };

        let asset_filter = match policy.currency {
            CurrencyCode::ETH => Some("ETH"),
            CurrencyCode::STRK => Some("STRK"),
            CurrencyCode::USDC => Some("USDC"),
            _ => None,
        };

        let bundle = zkpf_starknet_l2::prove_starknet_pof(
            &snapshot,
            &holder_id.0,
            policy.threshold as u64,
            asset_filter,
            &starknet_meta,
            &public_meta,
        )?;

        Ok(bundle)
    }

    async fn verify(&self, bundle: &ProofBundle) -> Result<bool, TachyonError> {
        let result = zkpf_starknet_l2::verify_starknet_proof(bundle)?;
        Ok(result.valid)
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// HELPER FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════

fn compute_nullifier(holder_id: &HolderId, policy: &Policy, epoch: &Epoch) -> [u8; 32] {
    let mut hasher = blake3::Hasher::new();
    hasher.update(b"tachyon_nullifier_v1");
    hasher.update(holder_id.0.as_bytes());
    hasher.update(&policy.policy_id.to_be_bytes());
    hasher.update(&policy.verifier_scope_id.to_be_bytes());
    hasher.update(&epoch.timestamp.to_be_bytes());
    *hasher.finalize().as_bytes()
}

fn compute_holder_binding(holder_id: &HolderId) -> [u8; 32] {
    let mut hasher = blake3::Hasher::new();
    hasher.update(b"tachyon_holder_binding_v1");
    hasher.update(holder_id.0.as_bytes());
    *hasher.finalize().as_bytes()
}

// Re-export
pub use crate::config::RailCapability;

