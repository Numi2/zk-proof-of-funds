// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {BN254Pairing} from "./BN254Pairing.sol";

/**
 * @title MinaKimchiVerifier
 * @notice Verifies BN254-wrapped Mina Proof of State proofs on-chain
 * @dev This contract verifies Groth16 proofs generated by the BN254 wrapper circuit
 *      that wraps the original Kimchi/Pickles proof from Mina.
 *
 * Architecture:
 * 1. Mina generates a Kimchi proof over Pasta curves (not EVM-compatible)
 * 2. A BN254 wrapper circuit (zkpf-mina-kimchi-wrapper) verifies the Kimchi proof
 *    and produces a Groth16 proof over BN254 (EVM-compatible)
 * 3. This contract verifies the Groth16 proof using EVM precompiles
 *
 * The wrapped proof has a single public input: mina_digest
 * where mina_digest = H(bridge_tip_state_hash || candidate_state_hashes || candidate_ledger_hashes)
 *
 * Proof Format (stateProof bytes):
 * [0:4]     - Magic bytes "MINA"
 * [4:8]     - Version (uint32)
 * [8:72]    - proof.A (G1 point, 64 bytes)
 * [72:200]  - proof.B (G2 point, 128 bytes)
 * [200:264] - proof.C (G1 point, 64 bytes)
 * [264:296] - mina_digest public input (32 bytes)
 */
contract MinaKimchiVerifier {
    using BN254Pairing for BN254Pairing.G1Point;

    // ============================================================
    // CONSTANTS
    // ============================================================

    /// @notice Magic bytes for proof identification
    bytes4 public constant PROOF_MAGIC = bytes4("MINA");

    /// @notice Current proof format version
    uint32 public constant PROOF_VERSION = 1;

    /// @notice Minimum proof length in bytes
    uint256 public constant MIN_PROOF_LENGTH = 296;

    /// @notice Domain separator for Mina digest computation
    bytes32 public constant MINA_DIGEST_DOMAIN = keccak256("zkpf_mina_state_digest_v1");

    // ============================================================
    // VERIFICATION KEY (embedded for Mina Proof of State wrapper circuit)
    // ============================================================

    /// @notice Verification key component: alpha (G1)
    BN254Pairing.G1Point public vkAlpha;

    /// @notice Verification key component: beta (G2)
    BN254Pairing.G2Point public vkBeta;

    /// @notice Verification key component: gamma (G2)
    BN254Pairing.G2Point public vkGamma;

    /// @notice Verification key component: delta (G2)
    BN254Pairing.G2Point public vkDelta;

    /// @notice Verification key: IC (input commitment) points
    /// IC[0] is the constant term, IC[1] is for the mina_digest public input
    BN254Pairing.G1Point[] public vkIC;

    /// @notice Whether the verification key has been initialized
    bool public vkInitialized;

    /// @notice Admin address for key management
    address public admin;

    // ============================================================
    // ERRORS
    // ============================================================

    error InvalidProofMagic();
    error InvalidProofVersion();
    error InvalidProofLength();
    error VerificationKeyNotInitialized();
    error InvalidVerificationKey();
    error ProofVerificationFailed();
    error DigestMismatch();
    error OnlyAdmin();
    error VkAlreadyInitialized();

    // ============================================================
    // EVENTS
    // ============================================================

    event VerificationKeyUpdated(bytes32 indexed vkHash);
    event ProofVerified(bytes32 indexed minaDigest, bool valid);

    // ============================================================
    // MODIFIERS
    // ============================================================

    modifier onlyAdmin() {
        if (msg.sender != admin) revert OnlyAdmin();
        _;
    }

    // ============================================================
    // CONSTRUCTOR
    // ============================================================

    constructor(address _admin) {
        admin = _admin;
    }

    // ============================================================
    // ADMIN FUNCTIONS
    // ============================================================

    /**
     * @notice Initialize the verification key for the Mina wrapper circuit
     * @dev Can only be called once. The VK is derived from the trusted setup ceremony.
     * @param alpha Alpha point (G1)
     * @param beta Beta point (G2)
     * @param gamma Gamma point (G2)
     * @param delta Delta point (G2)
     * @param ic Array of IC points (length = num_public_inputs + 1)
     */
    function initializeVerificationKey(
        BN254Pairing.G1Point calldata alpha,
        BN254Pairing.G2Point calldata beta,
        BN254Pairing.G2Point calldata gamma,
        BN254Pairing.G2Point calldata delta,
        BN254Pairing.G1Point[] calldata ic
    ) external onlyAdmin {
        if (vkInitialized) revert VkAlreadyInitialized();
        if (ic.length < 2) revert InvalidVerificationKey();

        vkAlpha = alpha;
        vkBeta = beta;
        vkGamma = gamma;
        vkDelta = delta;

        // Copy IC points
        for (uint256 i = 0; i < ic.length; i++) {
            vkIC.push(ic[i]);
        }

        vkInitialized = true;

        // Emit VK hash for verification
        bytes32 vkHash = keccak256(
            abi.encodePacked(
                alpha.x, alpha.y,
                beta.x0, beta.x1, beta.y0, beta.y1,
                gamma.x0, gamma.x1, gamma.y0, gamma.y1,
                delta.x0, delta.x1, delta.y0, delta.y1
            )
        );
        emit VerificationKeyUpdated(vkHash);
    }

    /**
     * @notice Transfer admin role
     */
    function transferAdmin(address newAdmin) external onlyAdmin {
        admin = newAdmin;
    }

    // ============================================================
    // VERIFICATION FUNCTIONS
    // ============================================================

    /**
     * @notice Verify a Mina Proof of State wrapped proof
     * @param stateRoot Expected state root being attested
     * @param proof The BN254-wrapped Groth16 proof bytes
     * @return valid True if the proof is valid
     */
    function verifyMinaProof(
        bytes32 stateRoot,
        bytes calldata proof
    ) external view returns (bool valid) {
        if (!vkInitialized) revert VerificationKeyNotInitialized();

        // Parse and validate proof structure
        (
            BN254Pairing.G1Point memory proofA,
            BN254Pairing.G2Point memory proofB,
            BN254Pairing.G1Point memory proofC,
            bytes32 minaDigest
        ) = parseProof(proof);

        // Compute expected digest from state root
        // In production, this would include full public inputs reconstruction
        bytes32 expectedDigest = computeMinaDigest(stateRoot);

        // Verify the digest matches
        if (minaDigest != expectedDigest) {
            revert DigestMismatch();
        }

        // Verify the Groth16 proof
        valid = verifyGroth16Proof(proofA, proofB, proofC, minaDigest);

        emit ProofVerified(minaDigest, valid);
    }

    /**
     * @notice Verify a Groth16 proof with public inputs
     * @dev Implements the Groth16 verification equation:
     *      e(A, B) = e(alpha, beta) * e(vk_x, gamma) * e(C, delta)
     *      where vk_x = IC[0] + sum(publicInput[i] * IC[i+1])
     */
    function verifyGroth16Proof(
        BN254Pairing.G1Point memory a,
        BN254Pairing.G2Point memory b,
        BN254Pairing.G1Point memory c,
        bytes32 publicInput
    ) public view returns (bool) {
        if (!vkInitialized) revert VerificationKeyNotInitialized();

        // Compute vk_x = IC[0] + publicInput * IC[1]
        // For single public input (mina_digest)
        uint256 publicInputScalar = uint256(publicInput) % BN254Pairing.SCALAR_FIELD_ORDER;

        BN254Pairing.G1Point memory vk_x = BN254Pairing.scalarMul(vkIC[1], publicInputScalar);
        vk_x = BN254Pairing.add(vkIC[0], vk_x);

        // Prepare pairing inputs
        // Verification equation: e(-A, B) * e(alpha, beta) * e(vk_x, gamma) * e(C, delta) == 1
        BN254Pairing.G1Point[] memory p = new BN254Pairing.G1Point[](4);
        BN254Pairing.G2Point[] memory q = new BN254Pairing.G2Point[](4);

        // e(-A, B)
        p[0] = BN254Pairing.negate(a);
        q[0] = b;

        // e(alpha, beta)
        p[1] = vkAlpha;
        q[1] = vkBeta;

        // e(vk_x, gamma)
        p[2] = vk_x;
        q[2] = vkGamma;

        // e(C, delta)
        p[3] = c;
        q[3] = vkDelta;

        return BN254Pairing.pairingCheckBatch(p, q);
    }

    /**
     * @notice Verify multiple proofs in one call (gas efficient)
     * @param stateRoots Array of state roots
     * @param proofs Array of proof bytes
     * @return results Array of verification results
     */
    function verifyMinaProofBatch(
        bytes32[] calldata stateRoots,
        bytes[] calldata proofs
    ) external view returns (bool[] memory results) {
        require(stateRoots.length == proofs.length, "Length mismatch");

        results = new bool[](stateRoots.length);
        for (uint256 i = 0; i < stateRoots.length; i++) {
            results[i] = this.verifyMinaProof(stateRoots[i], proofs[i]);
        }
    }

    // ============================================================
    // INTERNAL FUNCTIONS
    // ============================================================

    /**
     * @notice Parse proof bytes into structured components
     */
    function parseProof(
        bytes calldata proof
    ) internal pure returns (
        BN254Pairing.G1Point memory a,
        BN254Pairing.G2Point memory b,
        BN254Pairing.G1Point memory c,
        bytes32 minaDigest
    ) {
        if (proof.length < MIN_PROOF_LENGTH) revert InvalidProofLength();

        // Validate magic bytes
        bytes4 magic = bytes4(proof[0:4]);
        if (magic != PROOF_MAGIC) revert InvalidProofMagic();

        // Validate version
        uint32 version = uint32(bytes4(proof[4:8]));
        if (version != PROOF_VERSION) revert InvalidProofVersion();

        // Parse proof.A (G1 point: 64 bytes at offset 8)
        a = BN254Pairing.G1Point(
            uint256(bytes32(proof[8:40])),
            uint256(bytes32(proof[40:72]))
        );

        // Parse proof.B (G2 point: 128 bytes at offset 72)
        b = BN254Pairing.G2Point(
            uint256(bytes32(proof[72:104])),   // x0
            uint256(bytes32(proof[104:136])),  // x1
            uint256(bytes32(proof[136:168])),  // y0
            uint256(bytes32(proof[168:200]))   // y1
        );

        // Parse proof.C (G1 point: 64 bytes at offset 200)
        c = BN254Pairing.G1Point(
            uint256(bytes32(proof[200:232])),
            uint256(bytes32(proof[232:264]))
        );

        // Parse mina_digest (32 bytes at offset 264)
        minaDigest = bytes32(proof[264:296]);
    }

    /**
     * @notice Compute mina_digest from state root
     * @dev In production, this would reconstruct the full public inputs
     *      For simplified verification, we hash the state root with domain separator
     */
    function computeMinaDigest(bytes32 stateRoot) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(MINA_DIGEST_DOMAIN, stateRoot));
    }

    // ============================================================
    // VIEW FUNCTIONS
    // ============================================================

    /**
     * @notice Get the verification key hash
     */
    function getVerificationKeyHash() external view returns (bytes32) {
        if (!vkInitialized) return bytes32(0);

        return keccak256(
            abi.encodePacked(
                vkAlpha.x, vkAlpha.y,
                vkBeta.x0, vkBeta.x1, vkBeta.y0, vkBeta.y1,
                vkGamma.x0, vkGamma.x1, vkGamma.y0, vkGamma.y1,
                vkDelta.x0, vkDelta.x1, vkDelta.y0, vkDelta.y1
            )
        );
    }

    /**
     * @notice Check if the verification key is initialized
     */
    function isVerificationKeyInitialized() external view returns (bool) {
        return vkInitialized;
    }

    /**
     * @notice Get the number of public inputs (IC length - 1)
     */
    function getNumPublicInputs() external view returns (uint256) {
        if (!vkInitialized) return 0;
        return vkIC.length - 1;
    }
}

